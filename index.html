<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>大 PDF 按需渲染</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    </script>

    <style>
      * {
        &::-webkit-scrollbar {
          width: 1px;
          height: 1px;
        }

        ::-webkit-scrollbar-track {
          border-radius: 4px;
          background-color: transparent;
        }

        &::-webkit-scrollbar-thumb {
          background-color: var(white);
          border-radius: 4px;

          &:hover {
            background-color: var(white);
          }
        }
      }
      body {
        margin: 0px;
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #pdfContainer {
        width: 100%;
        margin: 0 auto;
        overflow-x: hidden; /* 防止横向溢出 */
        /* 新增：强制显示纵向滚动条，设置最小高度确保可滚动 */
        overflow-y: scroll; /* 始终显示纵向滚动条（即使内容不足） */
        min-height: 100vh; /* 容器最小高度为屏幕高度，确保至少有滚动区域 */
      }

      #loading {
        text-align: center;
        position: fixed;
        right: 20px;
        bottom: 20px;
        background-color: black;
        color: white;
        z-index: 20;
        padding: 5px 20px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <!-- 容器用于承载所有 PDF 页面（Canvas） -->
    <div id="pdfContainer"></div>
    <!-- 加载状态提示 -->
    <div id="loading">加载中...</div>

    <script>
      // 多PDF配置（替换为你的PDF地址列表）
      // 按文件顺序手动列出 assets 文件夹下的所有 PDF
      const pdfSources = [
        "assets/01封面.pdf",
        "assets/02简历.pdf",
        "assets/03目录.pdf",
        "assets/04app1.pdf",
        "assets/05app2.pdf",
        "assets/06app3.pdf",
        "assets/07项目总结.pdf",
        "assets/08pc1.pdf",
        "assets/09pc2.pdf",
        "assets/10pc3.pdf",
        "assets/11项目总结.pdf",
        "assets/12营销.pdf",
        "assets/13封底.pdf",
      ];
      const container = document.getElementById("pdfContainer");
      const loading = document.getElementById("loading");
      let pageScale = 1;
      const dpr = window.devicePixelRatio || 1;
      const loadedPages = new Map(); // 缓存已加载的页面：key为"pdfIndex-pageNum"
      let isRendering = false;

      // 当前加载状态
      let currentState = {
        pdfIndex: 0, // 当前处理的文档索引
        pageNum: 1, // 当前文档的当前页号
        totalLoadedHeight: 0, // 已加载内容的总高度
        isAllLoaded: false, // 是否所有文档都已加载完成
      };

      // 文档缓存（key为pdfIndex，值为pdfDoc实例）
      const pdfDocCache = new Map();

      // 工具函数：获取容器可用宽度
      function getContainerAvailableWidth() {
        const containerWidth = container.offsetWidth;
        const clientWidth = container.clientWidth;
        const scrollbarWidth = containerWidth - clientWidth;
        return clientWidth - (scrollbarWidth > 0 ? scrollbarWidth : 0);
      }

      // 工具函数：防抖
      function debounce(func, wait = 200) {
        let timeout;
        return function (...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      }

      // 加载指定文档（缓存）
      async function loadPdfDoc(pdfIndex) {
        if (pdfDocCache.has(pdfIndex)) {
          return pdfDocCache.get(pdfIndex);
        }
        if (pdfIndex >= pdfSources.length) {
          return null; // 文档索引越界
        }
        loading.textContent = `加载文档 ${pdfIndex + 1} / ${
          pdfSources.length
        }...`;
        const pdfDoc = await pdfjsLib.getDocument({
          url: pdfSources[pdfIndex],
          maxCanvasPixels: 8192 * 8192,
        }).promise;
        pdfDocCache.set(pdfIndex, pdfDoc);
        return pdfDoc;
      }

      // 渲染单页（返回该页渲染后的高度）
      async function renderSinglePage(pdfIndex, pageNum) {
        const key = `${pdfIndex}-${pageNum}`;
        // 1. 检查缓存中是否已存在
        if (loadedPages.has(key)) {
          // 2. 额外检查容器中是否已有该页面（防止重复添加）
          const existingCanvas = container.querySelector(
            `[data-pdf-index="${pdfIndex}"][data-page-num="${pageNum}"]`
          );
          if (existingCanvas) {
            return loadedPages.get(key).height; // 已存在则直接返回高度
          }
        }

        // 加载文档和页面
        const pdfDoc = await loadPdfDoc(pdfIndex);
        if (!pdfDoc) return 0;
        if (pageNum > pdfDoc.numPages) {
          return -1; // 该文档已无更多页面
        }
        const page = await pdfDoc.getPage(pageNum);

        // 计算缩放比例（以第一页为基准）
        if (pdfIndex === 0 && pageNum === 1) {
          const viewport = page.getViewport({ scale: 1 });
          const availableWidth = getContainerAvailableWidth();
          pageScale = availableWidth / viewport.width;
        }

        // 渲染页面
        const scaledViewport = page.getViewport({ scale: pageScale * dpr });
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");

        canvas.width = scaledViewport.width;
        canvas.height = scaledViewport.height;
        canvas.style.width = `${scaledViewport.width / dpr}px`;
        canvas.style.height = `${scaledViewport.height / dpr}px`;
        canvas.style.maxWidth = `${getContainerAvailableWidth()}px`;
        canvas.style.display = "block";
        canvas.style.margin = "0 auto";
        canvas.dataset.pdfIndex = pdfIndex;
        canvas.dataset.pageNum = pageNum;
        container.appendChild(canvas); // 仅在容器中不存在时添加

        context.imageSmoothingEnabled = true;
        context.imageSmoothingQuality = "high";
        await page.render({ canvasContext: context, viewport: scaledViewport })
          .promise;

        // 缓存页面信息
        loadedPages.set(key, {
          element: canvas,
          height: scaledViewport.height / dpr, // 记录显示高度
        });

        return scaledViewport.height / dpr;
      }

      // 加载首屏内容（按屏幕高度）
      async function loadFirstScreen() {
        if (isRendering || currentState.isAllLoaded) return;

        const screenHeight = window.innerHeight * 1.2; // 屏幕高度的1.2倍作为缓冲
        let currentPdfIndex = currentState.pdfIndex;
        let currentPageNum = currentState.pageNum;
        let accumulatedHeight = currentState.totalLoadedHeight;

        loading.textContent = "加载首屏内容...";
        isRendering = true; // 增加渲染锁，防止并发执行

        while (accumulatedHeight < screenHeight && !currentState.isAllLoaded) {
          // 渲染当前页
          const pageHeight = await renderSinglePage(
            currentPdfIndex,
            currentPageNum
          );

          if (pageHeight === -1) {
            // 当前文档已结束，切换到下一个文档
            currentPdfIndex++;
            currentPageNum = 1;
            if (currentPdfIndex >= pdfSources.length) {
              currentState.isAllLoaded = true;
              break;
            }
          } else if (pageHeight > 0) {
            // 页面渲染成功，累加高度并更新页码
            accumulatedHeight += pageHeight;
            currentPageNum++;
          } else {
            // 加载失败，终止循环
            break;
          }
        }

        // 更新状态
        currentState.pdfIndex = currentPdfIndex;
        currentState.pageNum = currentPageNum;
        currentState.totalLoadedHeight = accumulatedHeight;

        // 更新加载提示
        if (currentState.isAllLoaded) {
          loading.textContent = "所有内容已加载完成";
          setTimeout(() => (loading.style.display = "none"), 3000);
        } else {
          loading.textContent = `已加载至文档 ${currentPdfIndex + 1} / ${
            pdfSources.length
          }`;
        }
        isRendering = false; // 释放渲染锁
      }

      // 滚动加载更多（跨文档）
      async function loadMoreOnScroll() {
        if (isRendering || currentState.isAllLoaded) return;

        // 检查最后一个已加载页面是否接近视口底部
        const lastKey = Array.from(loadedPages.keys()).pop();
        if (!lastKey) return;

        const lastPage = loadedPages.get(lastKey).element;
        const lastPageBottom = lastPage.getBoundingClientRect().bottom;
        const viewportHeight = window.innerHeight;

        if (lastPageBottom < viewportHeight + 500) {
          isRendering = true;
          loading.textContent = `加载更多...（文档 ${
            currentState.pdfIndex + 1
          } / ${pdfSources.length}`;

          // 加载下2页（可能跨文档）
          let loadCount = 0;
          while (loadCount < 2 && !currentState.isAllLoaded) {
            const pageHeight = await renderSinglePage(
              currentState.pdfIndex,
              currentState.pageNum
            );

            if (pageHeight === -1) {
              // 当前文档结束，切换到下一个
              currentState.pdfIndex++;
              currentState.pageNum = 1;
              if (currentState.pdfIndex >= pdfSources.length) {
                currentState.isAllLoaded = true;
                break;
              }
            } else if (pageHeight > 0) {
              currentState.totalLoadedHeight += pageHeight;
              currentState.pageNum++;
              loadCount++;
            } else {
              break;
            }
          }

          // 更新状态提示
          if (currentState.isAllLoaded) {
            loading.textContent = "所有内容已加载完成";
            setTimeout(() => (loading.style.display = "none"), 3000);
          } else {
            loading.textContent = `已加载至文档 ${
              currentState.pdfIndex + 1
            } / ${pdfSources.length}`;
          }

          isRendering = false;
        }
      }

      // 窗口 resize 时重新加载首屏
      function handleResize() {
        // 清空现有内容
        container.innerHTML = "";
        loadedPages.clear();
        // 重置状态
        currentState = {
          pdfIndex: 0,
          pageNum: 1,
          totalLoadedHeight: 0,
          isAllLoaded: false,
        };
        // 重新加载首屏
        loadFirstScreen();
      }

      // 事件监听
      window.addEventListener("scroll", debounce(loadMoreOnScroll));
      window.addEventListener("resize", debounce(handleResize, 300));

      // 初始化：直接加载首屏
      loadFirstScreen();
    </script>
  </body>
</html>
